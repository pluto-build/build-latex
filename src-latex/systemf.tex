\subsection{Parametric Polymorphism }
\label{sec:systemf}

In the following, we present the co-contextual formulation of PCF extended with
parametric polymorphism. This extension is interesting with respect to our
co-contextual formulation because (i) the type checker can encounter type
applications without knowledge of the underlying universal type and (ii)
parametric polymorphism requires further context operations to ensure there are
no unbound type variables in a program. To support parametric polymorphism, we
first add new syntactic forms for type abstraction and application as well as
for type variables and universal types.

\vspace{1ex}
$
\newcommand{\comment}[1]{\text{#1}}
\begin{array}{c@{\hskip.5em}c@{\hskip.5em}lr}
  e & ::= & \ldots \OR \tabs{X}{e} \OR \tapp{e}{T} & \comment{type abstraction and application} \\
  T & ::= & \ldots \OR X \OR \TUniv{X}{T} \OR \TUniv{U}{T} & \comment{type variables and universal types} \\
  c & ::= & \ldots \OR \CSubst{T}{T}{X}{T} \OR \CSubst{T}{T}{U}{T} & \comment{type-substitution constraint} \\
\end{array}
$
\vspace{1ex}

\noindent Note that due to the constraint-based nature of co-contextual type
checking, we require support for universal types that quantify over
user-supplied type variables $X$ as well as unification type variables
$U$. Moreover, we require new constraints of the form
$\CSubst{T_1}{T_3}{X}{T_2}$ that express that $T_1$ is the result of
substituting $T_2$ for $X$ in $T_3$. We define similar constraint for
substituting unification variables. However, their semantics differ in that the
constraint solver must delay the substitution of a unification variable until it
is resolved to a proper type. For example, the substitution in
$\CSubst{T_1}{X}{U}{T_2}$ must be delayed because it might later turn out that
$U = X$. Furthermore, the constraint solver may not substitute user-supplied
type variables $X$ as they are not unification variables, hence the constraint
$X_1 = X_2 \to X_2$ does not hold. This distinction of type variables also
entails specific rules for the substitution and unification of universal types,
which permits the refinement of unification variables even when they appear as
binding or bound occurrences.

Since parametric polymorphism introduces bindings for type variables, we also
need to track that no unbound type variable occur in a program. A traditional
contextual type checker adds bound type variables to the typing context and
checks that all occurrences of type variables are indeed bound. We can use the
same strategy as for term variables (Section~\ref{sec:method}) to
co-contextualize type-variable handling. In particular, we introduce an
additional requirements component for type variables $\treqs \subset X$ and
extend our typing judgment $\cojudgePol {e} {T} {C} {\reqs} {\treqs}$ to
propagate required type variables $\treqs$. Dual to lookup and introduction of
type variables in contextual type checking, we produce type-variable
requirements when checking a user-supplied type for well-formedness
$\coTypeOK{T}{\treqs}$ and we eliminate type-variable requirements when binding
a type variable in a type-level $\lambda$-abstraction. As before, an expression
is only well-typed if all requirements are satisfied, that is, there are neither
term-variable nor type-variable requirements on the root of the syntax tree.

\input{cosystemf-constraint}

Figure~\ref{fig:co-systemf} shows the type rules for type abstraction, type
application, and term abstraction. %
Rule \rulename{T-TAbs} handles type abstraction $\tabs{X}{e}$. It eliminates
type-variable requirements on the bound type variable $X$ and propagates the
remaining type-variable requirements $\treqs - X$. %
Rule \rulename{T-TApp} handles type applications \tapp{e}{T}. It checks the
subexpression $e$ for well-typedness and the application type $T$ for
well-formedness and propagates their combined type-variable requirements
$\treqs_e \cup \treqs$. As the first constraint of \rulename{T-TApp} stipulates,
type application is only well-typed if the type of $e$ is a universal type
$\TUniv{U}{U_b}$. The type of the type application then is the result of
substituting $T$ for $U$ in $U_b$, as the second constraint defines.

Type rule \rulename{T-Abs} in Figure~\ref{fig:co-systemf} is an extended version
of the co-contextual PCF rule for $\lambda$-abstraction from
Figure~\ref{fig:co-pcf}. Due to the existence of type variables, we added a
premise that checks the well-formedness of the type annotation $T_1$. We
propagate the resulting type-variable requirements together with the
type-variable requirements of the function body. Finally, type rule
\rulename{T-App} illustrates how to extend all other rules of PCF such that they
merge and propagate type-variable requirements from subexpressions. Note that
due to the simplicity of type-variable requirements, the merge operation is
simply set union. We would require a more sophisticated merge operation when
introducing type variables of different kinds, for example, to realize
higher-order polymorphism.

To illustrate these type rules, consider the co-contextual type checking of the
polymorphic identity function instantiated for $\TNum$: $\tapp{(\tabs{X}{\abs{x}{X}{x}})}{\TNum}$.
%
\begin{center}
\begin{tikzpicture}[exp tree]
\node (tapp) at (0,4.5) {\tappNode[\TNum{}]};
 \node (lambda-a) at (0,3) {$\lambda X$};
  \node (lambda-x) at (0,2) {\absNode{x}{X}};
  \node (x) at (0,1) {$x$};

 \node[type node, right=of tapp] (tapp-type){\typeNode{U_r}};
  \node[ctx node, right=of tapp-type]  (tapp-cons)  {\consNode{\begin{array}{lll}%
     \{%
      &U_0 = X,\\%
      &\TUniv{X}{(X\to U_0)} = \TUniv{U}{U_b},\\%
      &\CSubst{U_r}{U_b}{U}{\TNum}%
      &\}%
  \end{array}}};
  \node[ctx node, right=of tapp-cons]  (tapp-req)  {\reqNode{(\emptyset,\emptyset)}}; 
  \node[type node, right=of lambda-a] (lambda-a-type){\typeNode{\TUniv{X}{(X\to U_0)}}};
  \node[ctx node, right=of lambda-a-type]  (lambda-a-cons)  {\consNode{\{U_0=X\}}};
 \node[ctx node, right=of lambda-a-cons]  (lambda-a-req)  {\reqNode{(\emptyset,\emptyset)}};
  \node[type node, right=of lambda-x] (lambda-x-type) {\typeNode{X\to U_0}};
  \node[ctx node, right=of lambda-x-type] (lambda-x-cons) {\consNode{\{U_0=X\}}};
  \node[ctx node, right=of lambda-x-cons] (lambda-x-req) {\reqNode{(\emptyset,\{X\})}}; 
  \node[type node,right=of x] (x-type) {\typeNode{U_0}};
  \node[ctx node,right=of x-type] (x-cons) {\consNode{\emptyset}}; 
  \node[ctx node, right=of x-cons]  (x-req)  {\reqNode{(x \ofType U_0, \emptyset)}};

 \path (tapp) edge (lambda-a);
 \path (lambda-a) edge (lambda-x);
 \path (lambda-x) edge (x);
\end{tikzpicture}
\end{center}
%
The type checker processes the expression bottom-up. First, it associates a fresh
unification variable $U_0$ to $x$. Second, $x$ is bound of type $X$, which
yields the constraint $U_0 = X$ and a type-variable requirement on $X$. Third,
this requirement is immediately discharged by the type-level
$\lambda$-abstraction that binds $X$. Finally, the type application rule
requires a universal type and computes the result type $U_r$ via a
type-substitution constraint. Subsequent constraint solving yields the
substitution $\sigma = \{U_0 \smap X, U \smap X, U_b \smap\, (X \!\to\! X), U_r \smap\, (\TNum \!\to\! \TNum)\}$.

Our type system rejects expressions with unbound type variables. For example,
the expression $\abs{f}{\TNum \to X}{\app x 0}$ contains an unbound type
variable $X$. When type checking this expression in our type system, we receive
an unsatisfied type-variable requirement that represents this error precisely.
Furthermore, despite using constraints, our type system correctly prevents any
refinement of universally quantified type variables. For example, our type
system correctly rejects the expression $\tabs{X}{\abs{x}{X}{\add{x}{x}}}$,
which tries to refine $X$ to $\TNum$ to perform addition.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "document"
%%% End: 

